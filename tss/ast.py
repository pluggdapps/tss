# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2010 SKR Farms (P) LTD.

# -*- coding: utf-8 -*-

"""Module containing Node definition for all terminal and non-teminals nodes.

The AST tree is constructed according to the grammar. From the root
non-terminal use the children() method on every node to walk through the tree.

To walk throug the AST,
  * parse() the text, which returns the root non-terminal
  * Use children() method on every non-terminal node.
"""

# Gotcha : None
# Notes  : None
# Todo   : None

import sys, re

class ASTError( Exception ):
    pass


class Context( object ):
    def __init__( self, htmlindent=u'' ):
        self.htmlindent = htmlindent


# ------------------- AST Nodes (Terminal and Non-Terminal) -------------------

class Node( object ):

    def __init__( self, parser ):
        self.parser = parser
        self.parent = None

    def children( self ):
        """Tuple of childrens in the same order as parsed by the grammar rule.
        """
        return tuple()

    def validate( self ):
        """Validate this node and all the children nodes. Expected to be called
        before processing the nodes."""
        pass

    def headpass1( self, igen ):
        """Pre-processing phase 1, useful to implement multi-pass compilers"""
        [ x.headpass1( igen ) for x in self.children() ]

    def headpass2( self, igen ):
        """Pre-processing phase 2, useful to implement multi-pass compilers"""
        [ x.headpass2( igen ) for x in self.children() ]

    def generate( self, igen, *args, **kwargs ):
        """Code generation phase. The result must be an executable python
        script"""
        [ x.generate( igen, *args, **kwargs ) for x in self.children() ]

    def tailpass( self, igen ):
        """Post-processing phase 1, useful to implement multi-pass compilers"""
        [ x.tailpass( igen ) for x in self.children() ]

    def lstrip( self, chars ):
        """Strip the leftmost chars from the Terminal nodes. Each terminal node
        must return the remaining the characters.
        In case of the Non-terminal node, call all the children node's
        lstrip() method, until the caller recieves a non-empty return value.
        """
        pass

    def rstrip( self, chars ):
        """Strip the rightmost chars from the Terminal nodes. Each terminal node
        must return the remaining the characters.
        In case of the Non-terminal node, call all the children node's
        rstrip() method, until the caller recieves a non-empty return value.
        """
        pass

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return u''.join([ x.dump(context) for x in self.children() ])

    def ismatched( self, context ):
        """This interface should return a boolean indicating whether the html
        generated by this node is matched. If a node expects that the html
        might be mismatched.
        After replacing etree with lxml mismatched elements are automatically
        taken care."""
        return True

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """

    #---- Helper methods

    def stackcompute( self, igen, compute, astext=True ):
        """Push a new buf, execute the compute function, pop the buffer and
        append that to the parent buffer."""
        igen.pushbuf()
        compute()
        igen.popcompute( astext=astext )
        return None

    def getroot( self ):
        """Get root node traversing backwards from this `self` node."""
        node = self
        parent = node.parent
        while parent : node, parent = parent, parent.parent
        return node

    def bubbleup( self, attrname, value ):
        """Bubble up value `value` to the root node and save that as its
        attribute `attrname`"""
        rootnode = self.getroot()
        setattr( rootnode, attrname, value )

    def bubbleupaccum( self, attrname, value, to=None ):
        """Same as bubbleup(), but instead of assigning the `value` to
        `attrname`, it is appended to the list."""
        rootnode = self.getroot()
        l = getattr( rootnode, attrname, [] )
        l.append( value )
        setattr( rootnode, attrname, l )

    @classmethod
    def setparent( cls, parnode, childnodes ):
        [ setattr( n, 'parent', parnode ) for n in childnodes ]


class Terminal( Node ) :
    """Abstract base class for Tayra style's AST terminal nodes."""

    def __init__( self, parser, terminal=u'', **kwargs ):
        Node.__init__( self, parser )
        self.terminal = terminal
        [ setattr( self, k, v ) for k,v in kwargs.items() ]

    def __repr__( self ):
        return unicode( self.terminal )

    def __str__( self ):
        return unicode( self.terminal )

    def lstrip( self, chars ):
        """Strip off the leftmost characters from the terminal string. Return
        the remaining characters.
        """
        self.terminal = self.terminal.lstrip( chars )
        return self.terminal

    def rstrip( self, chars ):
        """Strip off the rightmost characters from the terminal string. Return
        the remaining characters.
        """
        self.terminal = self.terminal.rstrip( chars )
        return self.terminal

    def generate( self, igen, *args, **kwargs ):
        """Dump the content."""
        igen.puttext( self.dump(None) )

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return self.terminal

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """
        lead = ' ' * offset
        buf.write(lead + '<%s>: %r' % (self.__class__.__name__, self.terminal))
        buf.write('\n')


class NonTerminal( Node ):      # Non-terminal
    """Abstract base class for Tayra Style's AST non-terminalnodes."""

    def __init__( self, *args, **kwargs ) :
        parser = args[0]
        Node.__init__( self, parser )
        self._terms, self._nonterms = tuple(), tuple()

    def lstrip( self, chars ):
        """Strip off the leftmost characters from children nodes. Stop
        stripping on recieving non null string."""
        value = u''
        for c in self.children() :
            value = c.lstrip( chars )
            if value : break
        return value

    def rstrip( self, chars ):
        """Strip off the rightmost characters from children nodes. Stop
        stripping on recieving non null string."""
        value = u''
        children = list(self.children())
        children.reverse()
        for c in children :
            value = c.rstrip( chars )
            if value : break
        return value

    def flatten( self, attrnode, attrs ):
        """Instead of recursing through left-recursive grammar, flatten them
        into sequential list for looping on them later."""
        node, rclist = self, []

        if isinstance(attrs, basestring) :
            fn = lambda n : [ getattr(n, attrs) ]
        elif isinstance(attrs, (list,tuple)) :
            fn = lambda n : [ getattr(n, attr) for attr in attrs ]
        else :
            fn = attrs

        while node :
            rclist.extend( filter( None, list(fn(node))) )
            node = getattr(node, attrnode)
        rclist.reverse()
        return rclist


# ------------------- Non-terminal classes ------------------------

class Tss( NonTerminal ):
    """class to handle `tss` grammar."""

    def __init__( self, parser, stylesheets ) :
        NonTerminal.__init__( self, parser, stylesheets )
        self._nonterms = (self.stylesheets,) = (stylesheets,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context=None ):
        c = context or Context()
        return u''.join([ x.dump(c) for x in self.children() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + '-->tss: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+5, attrnames, showcoord) for x in self.children() ]


class StyleSheets( NonTerminal ):
    """class to handle `stylesheets` grammar."""

    def __init__( self, parser, stylesheets, stylesheet ) :
        NonTerminal.__init__( self, parser, stylesheets, stylesheet )
        self._nonterms = \
                self.stylesheets, self.stylesheet = stylesheets, stylesheet
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ) :
        return ''.join([ x.dump( context ) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'stylesheets', 'stylesheet' )


class StyleSheet( NonTerminal ):
    """class to handle `stylesheet` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'stylesheet: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Statement( NonTerminal ):
    """class to handle `statement` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'statement: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- CDATA

class Cdatas( NonTerminal ):
    """class to handle `cdatas` grammar."""

    def __init__( self, parser, cdatas, cdata ) :
        NonTerminal.__init__( self, parser, cdatas, cdata )
        self._nonterms = self.cdatas, self.cdata = cdatas, cdata
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ) :
        return ''.join([ x.dump( context ) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'cdatas', 'cdata' )


class Cdata( NonTerminal ):
    """class to handle `cdata` grammar."""

    def __init__( self, parser, cdo, cdata_conts, cdc ) :
        NonTerminal.__init__( self, parser, cdo, cdata_conts, cdc )
        self._nonterms = \
                self.cdo, self.cdata_conts, self.cdc = cdo, cdata_conts, cdc
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'cdata: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class CdataConts( NonTerminal ):
    """class to handle `cdata_conts` grammar."""

    def __init__( self, parser, cdata_conts, cdata_cont ) :
        NonTerminal.__init__( self, parser, cdata_conts, cdata_cont )
        self._nonterms = \
                self.cdata_conts, self.cdata_cont = cdata_conts, cdata_cont
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'cdata_conts', 'cdata_cont' )


class CdataCont( NonTerminal ):
    """class to handle `cdata_cont` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'cdata_cont: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#--- @Charset

class Charset( NonTerminal ):
    """class to handle `charset` grammar."""

    def __init__( self, parser, charset_sym, nonterm, semi ) :
        NonTerminal.__init__( self, parser, charset_sym, nonterm, semi )
        self._nonterms = self.charset_sym, self.nonterm = charset_sym, nonterm
        self._terms = (self.SEMICOLON,) = (semi,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'charset: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @Import

class Import( NonTerminal ) :
    """class to handle `import` grammar."""

    def __init__( self, parser, import_sym, nonterm, mediums, semi ) :
        NonTerminal.__init__( self, parser, import_sym, nonterm, mediums, semi )
        self._nonterms = \
            self.import_sym, self.nonterm, self.mediums = \
                import_sym, nonterm, mediums
        self._nonterms = filter( None, self._nonterms )
        self._terms = (self.SEMICOLON,) = (semi,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        return self._nonterms + self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'import: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @namespace

class Namespace( NonTerminal ):
    """class to handle `namespace` grammar."""

    def __init__( self, parser, namespace_sym, prefix, nonterm, semi ) :
        NonTerminal.__init__( self, parser, namespace_sym, prefix, nonterm, semi )
        self._nonterms = \
            self.namespace_sym, self.prefix, self.nonterm = \
                namespace_sym, prefix, nonterm
        self._nonterms = filter( None, self._nonterms )
        self._terms = (self.SEMICOLON,) = (semi,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return ( self.namespace_sym, self.prefix, self.nonterm, self.SEMICOLON )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'namespace: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class NamePrefix( NonTerminal ) :
    """class to handle `nmprefix` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        txt = ''.join([ x.dump(context) for x in self.selectorlist() ])
        buf.write( lead + 'nmprefix: %r' % txt )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')


#---- @page

class Page( NonTerminal ) :
    """class to handle `page` grammar."""

    def __init__( self, parser, page_sym, ident, pseudo_page, block ) :
        NonTerminal.__init__( self, parser, page_sym, ident, pseudo_page, block )
        self.page_sym, self.pseudo_page, self.block = page_sym, pseudo_page, block
        if ident and isinstance( ident, IDENT ) :
            self.IDENT, self.ident = ident, None
        elif ident and isinstance( ident, TerminalS ) :
            self.IDENT, self.ident = None, ident
        self._nonterms = filter(
            None, self.page_sym, self.ident, self.pseudo_page, self.block
        )
        self._terms = filter( None, (self.IDENT,) )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        x = (self.page_sym, self.IDENT, self.ident, self.pseudo_page, self.block)
        return filter( None, x )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False) :
        lead = ' ' * offset
        buf.write( lead + 'page: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class PseudoPage( NonTerminal ) :
    """class to handle `pseudo_page` grammar."""

    def __init__( self, parser, colon, ident ) :
        NonTerminal.__init__( self, parser, colon, ident )
        self._nonterms = (self.ident,) = (ident,)
        self._terms = (self.COLON,) = (colon,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        return (self.COLON, self.ident)

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'pseudo_page: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @font_face

class FontFace( NonTerminal ) :
    """class to handle `font_face` grammar."""

    def __init__( self, parser, font_face_sym, block ) :
        NonTerminal.__init__( self, parser, font_face_sym, block )
        self._nonterms = self.font_face_sym, self.block = font_face_sym, block
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'font_face: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @media

class Media( NonTerminal ):
    """class to handle `media` grammar."""

    def __init__( self, parser, media_sym, mediums, block ) :
        NonTerminal.__init__( self, parser, media_sym, mediums, block )
        self._nonterms = \
            self.media_sym, self.mediums, self.block = media_sym, mediums, block
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'media: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Mediums( NonTerminal ):
    """class to handle `mediums` grammar."""

    def __init__( self, parser, mediums, comma, medium ) :
        NonTerminal.__init__( self, parser, mediums, comma, medium )
        self._nonterms = \
                self.mediums, self.comma, self.medium = mediums, comma, medium
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'mediums', ('medium', 'comma') )


class Medium( NonTerminal ) :
    """class to handle `medium` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'medium: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class AtRule( NonTerminal ) :
    """class to handle `atrule` grammar."""

    def __init__( self, parser, atkeyword, expr, semi, block ) :
        NonTerminal.__init__( self, parser, atkeyword, expr, semi, block )
        self._nonterms = \
            self.atkeyword, self.expr, self.block = atkeyword, expr, block
        self._nonterms = filter( None, self._nonterms )
        self._terms = (self.SEMICOLON,) = (semi,)
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter(
            None, (self.atkeyword, self.expr, self.SEMICOLON, self.block) )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'atrule: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Rulesets

class RuleSets( NonTerminal ):
    """class to handle `rulesets` grammar."""

    def __init__( self, parser, rulesets, ruleset ) :
        NonTerminal.__init__( self, parser, rulesets, ruleset )
        self._nonterms = self.rulesets, self.ruleset = rulesets, ruleset
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'rulesets', 'ruleset' )


class RuleSet( NonTerminal ):
    """class to handle `ruleset` grammar."""

    def __init__( self, parser, selectors, block, namespace_ext ) :
        NonTerminal.__init__( self, parser, selectors, block , namespace_ext )
        if namespace_ext :
            self.PERCENT, self.ident, self.expr, self.block = namespace_ext
            self._terms = (self.PERCENT,)
            self._nonterms = filter( None, (self.ident, self.expr, self.block) )
        else :
            self._nonterms = self.selectors, self.block = selectors, block
            self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )


    def children( self ):
        if self._terms :
            return filter(None, (self.PERCENT,self.ident,self.expr,self.block))
        else :
            return filter( None, (self.selectors, self.block) )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'ruleset: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Selectors( NonTerminal ):
    """class to handle `selectors` grammar."""

    def __init__( self, parser, selectors, comma, selector ) :
        NonTerminal.__init__( self, parser, selectors, comma, selector )
        self._nonterms = \
            self.selectors,self.comma,self.selector = selectors,comma,selector
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'selectors', ('selector', 'comma') )


class Selector( NonTerminal ):
    """class to handle `selector` grammar."""

    def __init__( self, parser, selector, combinator, simple_selector ) :
        NonTerminal.__init__( self, parser, selector, combinator, simple_selector )
        self._nonterms = \
            self.selector, self.combinator, self.simple_selector= \
                selector, combinator, simple_selector
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'selector', ('simple_selector', 'combinator') )


class SimpleSelector( NonTerminal ):
    """class to handle `simple_selector` grammar."""

    def __init__(self, parser, simple_selector, elemname, extender, extn_expr):
        NonTerminal.__init__(
            self, parser, simple_selector, elemname, extender, extn_expr )
        self._nonterms = \
            self.simple_selector, self.elemname, self.extender, self.extn_expr=\
                simple_selector, elemname, extender, extn_expr
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'simple_selector: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElementName( NonTerminal ):
    """class to handle `element_name` grammar."""

    def __init__( self, parser, nonterm, dlimit ) :
        NonTerminal.__init__( self, parser, nonterm, dlimit )
        self._nonterms = (self.nonterm,) = (nonterm,)
        self._nonterms = filter( None, self._nonterms )
        self._terms = (self.DLIMIT,) = (dlimit,)
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'element_name: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Combinator( NonTerminal ):
    """class to handle `combinator` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'combinator: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Extender( NonTerminal ):
    """class to handle `extender` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'extender: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Class( NonTerminal ):
    """class to handle `class` grammar."""

    def __init__( self, parser, dot, ident, wc ) :
        NonTerminal.__init__( self, parser, dot, ident, wc )
        self._nonterms = (self.wc,) = (wc,)
        self._nonterms = filter( None, self._nonterms )
        self._terms = self.DOT, self.IDENT = dot, ident
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'class: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Attrib( NonTerminal ) :
    """class to handle `attrib` grammar."""

    def __init__( self, parser, osqr, ident, attroper, attrval, csqr ) :
        NonTerminal.__init__(
                self, parser, osqr, ident, attroper, attrval, csqr )
        self._nonterms = \
            self.opensqr, self.ident, self.attroper, self.attrval, self.closesqr = \
                osqr, ident, attroper, attrval, csqr
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'attrib: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class AttrOper( NonTerminal ):
    """class to handle `attr_oper` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'attr_oper: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class AttrVal( NonTerminal ):
    """class to handle `attr_val` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'attr_val: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Pseudo( NonTerminal ):
    """class to handle `pseudo` grammar."""

    def __init__( self, parser, colon1, colon2, pseudo_name ) :
        NonTerminal.__init__( self, parser, colon1, colon2, pseudo_name )
        self._nonterms = (self.pseudo_name,) = (pseudo_name,)
        self._terms = self.COLON1, self.COLON2 = colon1, colon2
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'pseudo: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class PseudoName( NonTerminal ):
    """class to handle `pseudo_name` grammar."""

    def __init__( self, parser, ident, function, nonterm, cparan ) :
        NonTerminal.__init__( self, parser, ident, function, nonterm, cparan )
        self._nonterms = \
            self.ident, self.function, self.nonterm, self.closeparan = \
                ident, function, nonterm, cparan
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'pseudo_name: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Blocks

#class Blocks( NonTerminal ):
#    """class to handle `blocks` grammar."""
#
#    def __init__( self, parser, blocks, block ) :
#        NonTerminal.__init__( self, parser, blocks, block )
#        self._nonterms = self.blocks, self.block = blocks, block
#        self._nonterms = filter( None, self._nonterms )
#
#    def children( self ):
#        return self._nonterms
#
#    def tohtml( self ):
#        pass
#
#   def dump( self, context ):
#        return ''.join([ x.dump(context) for x in self.children() ])
#
#    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
#        lead = ' ' * offset
#        buf.write( lead + 'blocks: ' )
#        if showcoord:
#            buf.write( ' (at %s)' % self.coord )
#        buf.write('\n')
#        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Block( NonTerminal ):
    """class to handle `block` grammar."""

    def __init__( self, parser, obrace, declarations, cbrace ) :
        NonTerminal.__init__( self, parser, obrace, declarations, cbrace )
        self._nonterms = \
            self.openbrace, self.declarations, self.closebrace = \
                obrace, declarations, cbrace
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'block: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Declarations( NonTerminal ):
    """class to handle `declarations` grammar."""

    def __init__( self, parser, declarations, semi, nonterm ) :
        NonTerminal.__init__( self, parser, declarations, semi, nonterm )
        self._nonterms = \
            self.declarations, self.semicolon, self.nonterm = \
                declarations, semi, nonterm
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'declarations', ('nonterm', 'semicolon') )


class Declaration( NonTerminal ):
    """class to handle `declaration` grammar."""

    def __init__( self, parser, prefix, extn_expr, ident, colon, expr, prio ) :
        NonTerminal.__init__(
                self, parser, prefix, extn_expr, ident, colon, expr, prio )
        self._nonterms = \
            self.prefix, self.extn_expr, self.ident, self.colon, self.expr, self.prio = \
                prefix, extn_expr, ident, colon, expr, prio
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'declaration: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Priority( NonTerminal ):
    """class to handle `prio` grammar."""

    def __init__( self, parser, important_sym ) :
        NonTerminal.__init__( self, parser, important_sym )
        self._nonterms = (self.important_sym,) = (important_sym,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'prio: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Expressions

class Expr( NonTerminal ):
    """class to handle `expr` grammar."""

    def __init__( self, parser, expr, binaryexpr ) :
        NonTerminal.__init__( self, parser, expr, binaryexpr )
        self._nonterms = self.expr, self.binaryexpr = expr, binaryexpr
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'expr', 'binaryexpr' )


# Gotcha : There is a possibility of deep recursion here, although for
# practical inputs, it may not happen.

class BinaryExpr( NonTerminal ):
    """class to handle `binaryexpr` grammar."""

    def __init__( self, parser, nonterm, binaryexpr1, op, binaryexpr2 ) :
        NonTerminal.__init__( self, parser )
        self._nonterms = \
            self.nonterm, self.binaryexpr1, self.operator, self.binaryexpr2 = \
                nonterm, binaryexpr1, op, binaryexpr2
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'binaryexpr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


# Gotcha : This node can make an indirect recursive call to expr, hence end up
# in deep recursion

class UnaryExpr( NonTerminal ):
    """class to handle `unaryexpr` grammar."""

    def __init__( self, parser, unaryop, term_val, paran_expr ) :
        NonTerminal.__init__( self, parser, unaryop, term_val )
        if paran_expr :
            self._nonterms=self.openparan,self.expr,self.closeparan=paran_expr
        else :
            self._nonterms = self.unaryop, self.term_val = unaryop, term_val
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'unaryexpr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Term( NonTerminal ):
    """class to handle `term` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'term: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class TermVal( NonTerminal ):
    """class to handle `term_val` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'term_val: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


# Gotcha : This node can make an indirect recursive call to expr, hence end up
# in deep recursion

class FuncCall( NonTerminal ):
    """class to handle `func_call` grammar."""

    def __init__( self, parser, function, expr, closeparan ) :
        NonTerminal.__init__( self, parser, function, expr, closeparan )
        self._nonterms = \
            self.function, self.expr, self.closeparan = \
                function, expr, closeparan
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'func_call: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Operator( NonTerminal ):
    """class to handle `operator` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'operator: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#class Unary( NonTerminal ):
#    """class to handle `unary_oper` grammar."""
#
#    def __init__( self, parser, nonterm ) :
#        NonTerminal.__init__( self, parser, nonterm )
#        self._nonterm = ( self.nonterm, ) = (nonterm,)
#        # Set parent attribute for children, should be last statement !! 
#        self.setparent( self, self.children() )
#
#    def children( self ):
#        return self._nonterms
#
#    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
#        lead = ' ' * offset
#        buf.write( lead + 'unary_oper: ' )
#        if showcoord:
#            buf.write( ' (at %s)' % self.coord )
#        buf.write('\n')
#        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

#---- Terminals

class TerminalS( NonTerminal ):
    """class to handle terminal tokens is optionally succeeded by whitespace
    grammar."""

    def __init__( self, parser, terminal, wc ) :
        NonTerminal.__init__( self, parser, terminal, wc )
        self._terms = (self.TERMINAL,) = (terminal,)
        self._nonterms = (self.wc,) = (wc,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'TerminalS: (%s)' % type(self.TERMINAL) )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class WC( NonTerminal ):
    """class to handle `wc` grammar."""

    def __init__( self, parser, wc, s, comment ) :
        NonTerminal.__init__( self, parser, wc, s, comment )
        self._nonterms = (self.wc,) = (wc,)
        self._nonterms = filter( None, self._nonterms )
        self._terms = self.S, self.COMMENT = s, comment
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'wc', ('S', 'COMMENT') )


class Any( NonTerminal ):
    """class to handle `any` grammar."""

    def __init__( self, parser, osqr, expr, csqr ) :
        NonTerminal.__init__( self, parser, osqr, expr, csqr )
        self._nonterms = self.opensqr, self.expr, self.closesqr = osqr,expr,csqr
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.children() ]


#---- Extension language

class ExtnExpr( NonTerminal ):
    """class to handle `extn_expr` grammar."""

    def __init__( self, parser, extn_expr, ws ) :
        NonTerminal.__init__( self, parser, extn_expr, ws )
        self._terms = self.EXTN_EXPR, self.S = extn_expr, ws
        self._terms = filter( None, self._terms )

    def children( self ):
        return self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'extn_expr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class FunctionDef( NonTerminal ):
    """class to handle `functiondef` grammar."""

    def __init__( self, parser, functionstart, functionbody ) :
        NonTerminal.__init__( self, parser, functionstart, functionbody )
        self._nonterms = self.functionstart, self.functionbody = \
                functionstart, functionbody

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'functiondef: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class IfelfiBlock( NonTerminal ):
    """class to handle `ifelfiblock` grammar."""

    def __init__( self, parser, ifblock, ifelfiblock, controlblock ) :
        NonTerminal.__init__( self, parser, ifblock, ifelfiblock, controlblock )
        self._nonterms = self.ifblock, self.ifelfiblock, self.controlblock = \
                ifblock, ifelfiblock, controlblock
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'ifelfiblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class IfBlock( NonTerminal ):
    """class to handle `ifblock` grammar."""

    def __init__( self, parser, ifcontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, ifcontrol, declarations, closebrace )
        self._nonterms = self.ifcontrol, self.declarations, self.closebrace = \
                ifcontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'ifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElifBlock( NonTerminal ):
    """class to handle `elifblock` grammar."""

    def __init__( self, parser, elifcontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, elifcontrol, declarations, closebrace )
        self._nonterms = self.elifcontrol, self.declarations, self.closebrace = \
                elifcontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'elifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElseBlock( NonTerminal ):
    """class to handle `elseblock` grammar."""

    def __init__( self, parser, elsecontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, elsecontrol, declarations, closebrace )
        self._nonterms = self.elsecontrol, self.declarations, self.closebrace = \
                elsecontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'elseblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ForBlock( NonTerminal ):
    """class to handle `forblock` grammar."""

    def __init__( self, parser, forcontrol, declaration, closebrace ) :
        NonTerminal.__init__( self, parser, forcontrol, declarations, closebrace )
        self._nonterms = self.forcontrol, self.declarations, self.closebrace = \
                forcontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'functiondef: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class WhileBlock( NonTerminal ):
    """class to handle `whileblock` grammar."""

    def __init__( self, parser, whilecontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, whilecontrol, declarations, closebrace )
        self._nonterms = \
            self.whilecontrol, self.declarations, self.closebrace = \
                whilecontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'whileblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#-------------------------- AST Terminals -------------------------

class IMPORT_SYM( Terminal ) : pass
class PAGE_SYM( Terminal ) : pass
class MEDIA_SYM( Terminal ) : pass
class FONT_FACE_SYM( Terminal ) : pass
class CHARSET_SYM( Terminal ) : pass
class NAMESPACE_SYM( Terminal ) : pass
class IMPORTANT_SYM( Terminal ) : pass
class ATKEYWORD( Terminal ) : pass

class CDO( Terminal ) : pass
class CDC( Terminal ) : pass
class S( Terminal ) : pass
class COMMENT( Terminal ) : pass

class IDENT( Terminal ) : pass
class URI( Terminal ) : pass
class FUNCTION( Terminal ) : pass

class HASH( Terminal ) : pass
class INCLUDES( Terminal ) : pass
class DASHMATCH( Terminal ) : pass
class PREFIXMATCH( Terminal ) : pass
class SUFFIXMATCH( Terminal ) : pass
class SUBSTRINGMATCH( Terminal ) : pass

class STRING( Terminal ) : pass
class NUMBER( Terminal ) : pass
class PERCENTAGE( Terminal ) : pass
class DIMENSION( Terminal ):
    def dump( self, context ):
        return self.terminal.__str__()

class UNICODERANGE( Terminal ) : pass
class DLIMIT( Terminal ) : pass

class PLUS( Terminal ) : pass
class MINUS( Terminal ) : pass
class GT( Terminal ) : pass
class LT( Terminal ) : pass
class TILDA( Terminal ) : pass
class COMMA( Terminal ) : pass
class COLON( Terminal ) : pass
class EQUAL( Terminal ) : pass
class DOT( Terminal ) : pass
class STAR( Terminal ) : pass
class SEMICOLON( Terminal ) : pass
class FWDSLASH( Terminal ) : pass
class OPENBRACE( Terminal ) : pass
class CLOSEBRACE( Terminal ) : pass
class OPENSQR( Terminal ) : pass
class CLOSESQR( Terminal ) : pass
class OPENPARAN( Terminal ) : pass
class CLOSEPARAN( Terminal ) : pass

class EXTN_EXPR( Terminal ) : pass
class EXTN_STATEMENT( Terminal ) : pass
class PERCENT( Terminal ) : pass
class FUNCTIONSTART( Terminal ) : pass
class FUNCTIONBODY( Terminal ) : pass
class IFCONTROL( Terminal ) : pass
class ELIFCONTROL( Terminal ) : pass
class ELSECONTROL( Terminal ) : pass
class FORCONTROL( Terminal ) : pass
class WHILECONTROL( Terminal ) : pass

# TODO : Why are these terminal here ?
class HEXCOLOR( Terminal ) : pass
class NAME( Terminal ) : pass
class FUNCTIONEND( Terminal ) : pass

#---------------------------- Terminal Literals --------------------------

class Dimension( object ):
    def __init__( self, value ):
        self.value = value
    def __str__( self ):
        return self.value

class Ems( Dimension ): pass
class Exs( Dimension ): pass
class LengthPX( Dimension ): pass
class LengthCM( Dimension ): pass
class LengthMM( Dimension ): pass
class LengthIN( Dimension ): pass
class LengthPT( Dimension ): pass
class LengthPC( Dimension ): pass
class AngleDEG( Dimension ): pass
class AngleRAD( Dimension ): pass
class AngleGRAD( Dimension ): pass
class TimeMS( Dimension ): pass
class TimeS( Dimension ): pass
class FreqHZ( Dimension ): pass
class FreqKHZ( Dimension ): pass
class Percentage( Dimension ): pass
