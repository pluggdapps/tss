# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2010 SKR Farms (P) LTD.

# -*- coding: utf-8 -*-

"""Module containing Node definition for all terminal and non-teminals nodes.

The AST tree is constructed according to the grammar. From the root
non-terminal use the children() method on every node to walk through the tree.

To walk throug the AST,
  * parse() the text, which returns the root non-terminal
  * Use children() method on every non-terminal node.
"""

# Gotcha : None
# Notes  : None
# Todo   : None

import sys, re
from   tss.utils        import charset, throw

class ASTError( Exception ):
    pass


class Context( object ):
    def __init__( self, htmlindent=u'' ):
        self.htmlindent = htmlindent


# ------------------- AST Nodes (Terminal and Non-Terminal) -------------------

class Node( object ):

    def __init__( self, parser ):
        self.parser = parser
        self.parent = None

    def children( self ):
        """Tuple of childrens in the same order as parsed by the grammar rule.
        """
        return tuple()

    def validate( self, context ):
        """Validate this node and all the children nodes. Expected to be called
        before processing the nodes.
        
        If no issue with validation, returns True"""
        return True

    def headpass1( self, igen ):
        """Pre-processing phase 1, useful to implement multi-pass compilers"""
        [ x.headpass1( igen ) for x in self.children() ]

    def headpass2( self, igen ):
        """Pre-processing phase 2, useful to implement multi-pass compilers"""
        [ x.headpass2( igen ) for x in self.children() ]

    def generate( self, igen, *args, **kwargs ):
        """Code generation phase. The result must be an executable python
        script"""
        [ x.generate( igen, *args, **kwargs ) for x in self.children() ]

    def tailpass( self, igen ):
        """Post-processing phase 1, useful to implement multi-pass compilers"""
        [ x.tailpass( igen ) for x in self.children() ]

    def lstrip( self, chars ):
        """Strip the leftmost chars from the Terminal nodes. Each terminal node
        must return the remaining the characters.
        In case of the Non-terminal node, call all the children node's
        lstrip() method, until the caller recieves a non-empty return value.
        """
        pass

    def rstrip( self, chars ):
        """Strip the rightmost chars from the Terminal nodes. Each terminal node
        must return the remaining the characters.
        In case of the Non-terminal node, call all the children node's
        rstrip() method, until the caller recieves a non-empty return value.
        """
        pass

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return u''.join([ x.dump(context) for x in self.children() ])

    def ismatched( self, context ):
        """This interface should return a boolean indicating whether the html
        generated by this node is matched. If a node expects that the html
        might be mismatched.
        After replacing etree with lxml mismatched elements are automatically
        taken care."""
        return True

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """

    #---- Helper methods

    def stackcompute( self, igen, compute, astext=True ):
        """Push a new buf, execute the compute function, pop the buffer and
        append that to the parent buffer."""
        igen.pushbuf()
        compute()
        igen.popappend( astext=astext )
        return None

    def getroot( self ):
        """Get root node traversing backwards from this `self` node."""
        node = self
        parent = node.parent
        while parent : node, parent = parent, parent.parent
        return node

    def bubbleup( self, attrname, value ):
        """Bubble up value `value` to the root node and save that as its
        attribute `attrname`"""
        rootnode = self.getroot()
        setattr( rootnode, attrname, value )

    def bubbleupaccum( self, attrname, value, to=None ):
        """Same as bubbleup(), but instead of assigning the `value` to
        `attrname`, it is appended to the list."""
        rootnode = self.getroot()
        l = getattr( rootnode, attrname, [] )
        l.append( value )
        setattr( rootnode, attrname, l )

    @classmethod
    def setparent( cls, parnode, childnodes ):
        [ setattr( n, 'parent', parnode ) for n in childnodes ]


class Terminal( Node ) :
    """Abstract base class for Tayra style's AST terminal nodes."""

    def __init__( self, parser=None, terminal=u'', **kwargs ):
        Node.__init__( self, parser )
        self.terminal = terminal
        [ setattr( self, k, v ) for k,v in kwargs.items() ]

    def __repr__( self ):
        return unicode( self.terminal )

    def __str__( self ):
        return unicode( self.terminal )

    def lstrip( self, chars ):
        """Strip off the leftmost characters from the terminal string. Return
        the remaining characters.
        """
        self.terminal = self.terminal.lstrip( chars )
        return self.terminal

    def rstrip( self, chars ):
        """Strip off the rightmost characters from the terminal string. Return
        the remaining characters.
        """
        self.terminal = self.terminal.rstrip( chars )
        return self.terminal

    def generate( self, igen, *args, **kwargs ):
        """Dump the content."""
        igen.pushtext( self.dump(None) )

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return self.terminal

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """
        lead = ' ' * offset
        buf.write(lead + '<%s>: %r' % (self.__class__.__name__, self.terminal))
        buf.write('\n')


class NonTerminal( Node ):      # Non-terminal
    """Abstract base class for Tayra Style's AST non-terminalnodes."""

    def __init__( self, *args, **kwargs ) :
        parser = args[0]
        Node.__init__( self, parser )
        self._terms, self._nonterms = tuple(), tuple()

    def lstrip( self, chars ):
        """Strip off the leftmost characters from children nodes. Stop
        stripping on recieving non null string."""
        value = u''
        for c in self.children() :
            value = c.lstrip( chars )
            if value : break
        return value

    def rstrip( self, chars ):
        """Strip off the rightmost characters from children nodes. Stop
        stripping on recieving non null string."""
        value = u''
        children = list(self.children())
        children.reverse()
        for c in children :
            value = c.rstrip( chars )
            if value : break
        return value

    def flatten( self, attrnode, attrs ):
        """Instead of recursing through left-recursive grammar, flatten them
        into sequential list for looping on them later."""
        node, rclist = self, []

        if isinstance(attrs, basestring) :
            fn = lambda n : [ getattr(n, attrs) ]
        elif isinstance(attrs, (list,tuple)) :
            fn = lambda n : [ getattr(n, attr) for attr in attrs ]
        else :
            fn = attrs

        while node :
            rclist.extend( filter( None, list(fn(node))) )
            node = getattr(node, attrnode)
        rclist.reverse()
        return rclist


# ------------------- Non-terminal classes ------------------------

class Tss( NonTerminal ):
    """class to handle `tss` grammar."""

    def __init__( self, parser, tss, stylesheet ) :
        NonTerminal.__init__( self, parser, tss, stylesheet )
        self._nonterms = self.tss, self.stylesheet = tss, stylesheet
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

        # Initialization
        self.blocks = []    # List of all styling blocks { ... }

    def _hascontent( self ) :
        """Check whether the main of the template page contains valid content,
        if not then the `main` function should not be generated at all."""
        return True

    def _main( self, igen, signature=u'', *args, **kwargs ):
        """Generate the main function only when there is valid content in the
        global scope.
        """
        igen.cr()
        if self._hascontent() :
            # main function signature
            signature = signature and signature.strip(', \t') or u''
            u', '.join([ signature, '*args', '**kwargs' ])
            line = "def main( %s ) :" % signature
            igen.putstatement( line )
            igen.codeindent( up='  ' )
            igen.pushbuf()
            # Main function's children
            [ x.generate(igen, *args, **kwargs) for x in self.flatten() ]
            # finish main function
            igen.flushtext()
            igen.popreturn( astext=True )
            igen.codeindent( down='  ' )
        else :
            igen.flushtext()

    def children( self ):
        return self._nonterms

    def validate( self, context=None ):
        c = context or Context()
        return all([ x.validate(c) for x in self.flatten() ])

    def headpass1( self, igen ):
        [ x.headpass1( igen ) for x in self.flatten() ]

    def headpass2( self, igen ):
        igen.initialize()
        [ x.headpass2( igen ) for x in self.flatten() ]

    def generate( self, igen, *args, **kwargs ):
        self.tsshash = kwargs.pop( 'tsshash', u'' )
        self.tssfile = self.parser.tssparser.tssfile
        self._main( igen, signature=u'', *args, **kwargs )

    def tailpass( self, igen ):
        igen.cr()
        [ x.tailpass( igen ) for x in self.flatten() ]
        igen.comment( "---- Footer", force=True )
        igen.footer( self.tsshash, self.tssfile )
        igen.finish()

    def dump( self, context=None ):
        c = context or Context()
        return u''.join([ x.dump(c) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + '-->tss: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+5, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'tss', 'stylesheet' )


class StyleSheet( NonTerminal ):
    """class to handle `stylesheet` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'stylesheet: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- CDATA

class Cdata( NonTerminal ):
    """class to handle `cdata` grammar."""

    def __init__( self, parser, cdo, cdatatext, cdc ) :
        NonTerminal.__init__( self, parser, cdo, cdatatext, cdc )
        self._terms = self.CDO, self.CDATATEXT, self.CDC = cdo, cdatatext, cdc
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'cdata: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#--- @Charset

class Charset( NonTerminal ):
    """class to handle `charset` grammar."""

    def __init__( self, parser, sym, string, semi ) :
        NonTerminal.__init__( self, parser, sym, string, semi )
        self._terms = self.CHARSET_SYM, self.SEMICOLON = sym, semi
        self._nonterms = (self.string,) = (string,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self.CHARSET_SYM, self.string, self.SEMICOLON

    def headpass2( self, igen ):
        parseline = self.dump( None )
        defencoding = self.parser.tssparser.encoding
        igen.encoding = charset( parseline=parseline, encoding=defencoding )
        igen.comment( "-*- coding: %s -*-" % igen.encoding, force=True )
        igen.putstatement( "_m.setencoding( %r )" % igen.encoding )
        NonTerminal.headpass2( self, igen )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'charset: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @Import

class Import( NonTerminal ) :
    """class to handle `import` grammar."""

    def __init__( self, parser, sym, nonterm, mediums, semi ) :
        NonTerminal.__init__( self, parser, sym, nonterm, mediums, semi )
        self._terms = self.IMPORT_SYM, self.SEMICOLON = sym, semi
        self._terms = filter( None, self._terms )
        self._nonterms = self.nonterm, self.mediums = nonterm, mediums
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        x = self.IMPORT_SYM, self.nonterm, self.mediums, self.SEMICOLON
        return filter(None, x)

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'import: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @namespace

class Namespace( NonTerminal ):
    """class to handle `namespace` grammar."""

    def __init__( self, parser, sym, prefix, nonterm, semi ) :
        NonTerminal.__init__( self, parser, sym, prefix, nonterm, semi )
        self._terms = self.NAMESPACE_SYM, self.SEMICOLON = sym, semi
        self._terms = filter( None, self._terms )
        self._nonterms = self.prefix, self.nonterm = prefix, nonterm
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = self.NAMESPACE_SYM, self.prefix, self.nonterm, self.SEMICOLON
        return filter(None, x)

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'namespace: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @media

class Media( NonTerminal ):
    """class to handle `media` grammar."""

    def __init__( self, parser, sym, mediums, obrace, rulesets, cbrace ):
        NonTerminal.__init__(
            self, parser, sym, mediums, obrace, rulesets, cbrace )
        self._terms = (self.MEDIA_SYM,) = (sym,)
        self._terms = filter( None, self._terms )
        self._nonterms = \
            self.mediums, self.openbrace, self.rulesets, self.closebrace = \
                mediums, obrace, rulesets, cbrace
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        x = ( self.MEDIA_SYM, self.mediums, 
              self.openbrace, self.rulesets, self.closebrace )
        return filter(None, x)

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'media: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Mediums( NonTerminal ):
    """class to handle `mediums` grammar."""

    def __init__( self, parser, mediums, s, comma, ident ) :
        NonTerminal.__init__( self, parser, mediums, s, comma, ident )
        self._terms = self.S, self.COMMA, self.IDENT = (comma, s, ident)
        self._terms = filter( None, self._terms )
        self._nonterms = (self.mediums,) = (mediums,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None, (self.mediums, self.S, self.COMMA, self.IDENT) )

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'mediums', ('IDENT', 'COMMA', 'S') )

    def pushident( self, mediums ):
        if self.mediums :
            self.mediums.pushident( mediums )
        else :
            self.mediums = mediums


#---- @page

class Page( NonTerminal ) :
    """class to handle `page` grammar."""

    def __init__( self, parser, sym, ident1, colon, ident2, block ) :
        NonTerminal.__init__( self, parser, sym, ident1, colon, ident2, block )
        self._terms = self.PAGE_SYM, self.COLON = sym, colon
        self._terms = filter( None, self._terms )
        self._nonterms = \
            self.ident1, self.ident2, self.block = ident1, ident2, block
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ) :
        x = ( self.PAGE_SYM, self.ident1, self.COLON, self.ident2, self.block )
        return filter( None, x )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False) :
        lead = ' ' * offset
        buf.write( lead + 'page: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @font_face

class FontFace( NonTerminal ) :
    """class to handle `font_face` grammar."""

    def __init__( self, parser, sym, block ) :
        NonTerminal.__init__( self, parser, sym, block )
        self._terms = (self.FONT_FACE_SYM,) = (sym,)
        self._terms = filter( None, self._terms )
        self._nonterms = (self.block,) = (block,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None, (self.FONT_FACE_SYM, self.block) )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'font_face: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- @generic-atrule

class AtRule( NonTerminal ) :
    """class to handle `atrule` grammar."""

    def __init__( self, parser, sym, expr, block, semi, ruleblock ) :
        NonTerminal.__init__(self, parser, sym, expr, block, semi, ruleblock)
        self._terms = self.ATKEYWORD, self.SEMICOLON = sym, semi
        self._terms = filter( None, self._terms )
        self._nonterms = \
            self.expr, self.block, \
            self.openbrace, self.rulesets, self.closebrace = \
                (expr, block) + ruleblock
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.ATKEYWORD, self.expr, self.block, self.SEMICOLON,
              self.openbrace, self.rulesets, self.closebrace )
        return filter( None, x )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'atrule: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Rulesets

class Rulesets( NonTerminal ):
    """class to handle `rulesets` grammar."""

    def __init__( self, parser, rulesets, ruleset ) :
        NonTerminal.__init__( self, parser, rulesets, ruleset )
        self._nonterms = self.rulesets, self.ruleset = rulesets, ruleset
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'rulesets', 'ruleset' )


class Ruleset( NonTerminal ):
    """class to handle `ruleset` grammar."""

    def __init__( self, parser, selectors, block ) :
        NonTerminal.__init__( self, selectors, block )
        self._nonterms = self.selectors, self.block = selectors, block
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None, (self.selectors, self.block) )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'ruleset: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Selectors( NonTerminal ):
    """class to handle `selectors` grammar."""

    def __init__( self, parser, selectors, comma, selector ) :
        NonTerminal.__init__( self, parser, selectors, comma, selector )
        self._terms = (self.COMMA,) = (comma,)
        self._terms = filter( None, self._terms )
        self._nonterms = self.selectors, self.selector = selectors, selector
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None,  (self.selectors, self.COMMA, self.selector) )

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'selectors', ('selector', 'COMMA') )


class Selector( NonTerminal ):
    """class to handle `selector` grammar."""

    def __init__( self, parser, selector, combinator, simplesel ) :
        NonTerminal.__init__( self, parser, selector, combinator, simplesel )
        self._terms = (self.COMBINATOR,) = (combinator,)
        self._nonterms = self.selector,self.simple_selector = selector,simplesel
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = (self.selector, self.COMBINATOR, self.simple_selector)
        return filter( None, x )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'selector: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class SimpleSelector( NonTerminal ):
    """class to handle `simple_selector` grammar."""

    def __init__( self, parser, star, dot, ident, hashh, attrib, pseudo ):
        NonTerminal.__init__(self, parser, star, dot, ident, hashh, attrib, pseudo)
        self._terms = self.STAR, self.DOT = star, dot
        self._terms = filter( None, self._terms )
        self._nonterms = self.ident, self.hashh, self.attrib, self.pseudo = \
                ident, hashh, attrib, pseudo
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = self.STAR, self.DOT, self.ident, self.hashh, self.attrib, self.pseudo
        return filter( None, x )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'simple_selector: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Attrib( NonTerminal ) :
    """class to handle `attrib` grammar."""

    def __init__( self, parser, osqr, ident, oper, attrval, csqr ) :
        NonTerminal.__init__( self, parser, osqr, ident, oper, attrval, csqr )
        self._terms = (self.OPERATOR,) = (oper,)
        self._terms = filter( None, self._terms )
        self._nonterms = \
            self.opensqr, self.ident, self.attrval, self.closesqr = \
                osqr, ident, attrval, csqr
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.opensqr, self.ident, self.OPERATOR, self.attrval,
              self.closesqr )
        return filter(None, x)

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'attrib: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class AttrOperator( NonTerminal ):
    """class to handle `class` grammar."""

    def __init__( self, parser, term ) :
        NonTerminal.__init__( self, parser, term )
        self._terms = (self.TERMINAL,) = (term,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'attroperator: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Pseudo( NonTerminal ):
    """class to handle `pseudo` grammar."""

    def __init__( self, parser, colon1, colon2, nonterm ) :
        NonTerminal.__init__( self, parser, colon1, colon2, nonterm )
        self._terms = self.COLON1, self.COLON2 = colon1, colon2
        self._terms = filter( None, self._terms )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None, (self.COLON1, self.COLON2, self.nonterm) )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'pseudo: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Declaration block

class Block( NonTerminal ):
    """class to handle `block` grammar."""

    def __init__( self, parser, obrace, declarations, cbrace ) :
        NonTerminal.__init__( self, parser, obrace, declarations, cbrace )
        self._nonterms = \
            self.openbrace, self.declarations, self.closebrace = \
                obrace, declarations, cbrace
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'block: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Declarations( NonTerminal ):
    """class to handle `declarations` grammar."""

    def __init__( self, parser, declarations, semi, wc, nonterm ) :
        NonTerminal.__init__( self, parser, declarations, semi, wc, nonterm )
        self._terms = (self.SEMICOLON,) = (semi,)
        self._terms = filter( None, self._terms )
        self._nonterms = \
            self.declarations, self.wc, self.nonterm = declarations, wc, nonterm
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = self.declarations, self.SEMICOLON, self.wc, self.nonterm
        return filter( None, x )

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        attrs = ('nonterm', 'wc', 'SEMICOLON')
        return NonTerminal.flatten( self, 'declarations', attrs )


class Declaration( NonTerminal ):
    """class to handle `declaration` grammar."""

    def __init__( self, parser, prefix, ident, colon, exprs, prio ) :
        NonTerminal.__init__(self, parser, prefix, ident, colon, exprs, prio)
        self._terms = self.PREFIX, self.COLON, = prefix, colon
        self._terms = filter( None, self._terms )
        self._nonterms = self.ident, self.exprs, self.prio = ident, exprs, prio
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.PREFIX, self.ident, self.COLON, self.exprs, self.prio )
        return filter(None, x)

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'declaration: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Priority( NonTerminal ):
    """class to handle `prio` grammar."""

    def __init__( self, parser, sym, wc ) :
        NonTerminal.__init__( self, parser, sym )
        self._terms = (self.IMPORTANT_SYM,) = (sym,)
        self._nonterms = (self.wc,) = (wc,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'prio: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Expressions

class TerminalS( NonTerminal ):
    """Base class for all `term` terms. Implements `term` grammar rule"""

    def __init__( self, parser, terminal, wc ) :
        NonTerminal.__init__( self, parser, terminal, wc )
        self._terms = (self.TERMINAL,) = (terminal,)
        self._nonterms = (self.wc,) = (wc,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'TerminalS: %s' % self.TERMINAL.__class__ )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Exprs( NonTerminal ):
    """class to handle `exprs` grammar."""

    def __init__( self, parser, exprs, comma, expr ):
        NonTerminal.__init__( self, parser, exprs, comma, expr )
        self._terms = (self.COMMA,) = (comma,)
        self._nonterms = self.exprs, self.expr = exprs, expr
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None, (self.exprs, self.COMMA, self.expr) )

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'exprs: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'exprs', ('expr', 'COMMA') )


# Gotcha : There is a possibility of deep recursion here, although for
# practical inputs, it may not happen.

class Expr( NonTerminal ):
    """class to handle `expr` grammar."""

    def __init__( self, parser, term, spec, expr1, operator, expr2 ):
        NonTerminal.__init__(self, parser, term, spec, expr1, operator, expr2)
        self._terms = (self.OPERATOR,) = (operator,)
        self._terms = filter( None, self._terms )
        self._nonterms = self.term, self.spec, self.expr1, self.expr2 = \
                term, spec, expr1, expr2
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = self.term, self.spec, self.expr1, self.OPERATOR, self.expr2
        return filter( None, x )

    def generate( self, igen, *args, **kwargs ):
        NonTerminal.generate( self, igen, *args, **kwargs )
        if (self.expr1 == None) and isinstance( self.OPERATOR, (PLUS, MINUS) ) :
            igen.evalunary()
        if isinstance( self.OPERATOR, (PLUS, MINUS, STAR, FWDSLASH) ) :
            igen.evalbinary()

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'expr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ExprParan( NonTerminal ):
    """class to handle `( expr )` grammar."""

    def __init__( self, parser, oparan, expr, cparan ) :
        NonTerminal.__init__( self, parser, oparan, expr, cparan )
        self._nonterms = self.openparan, self.expr, self.closeparan = \
                oparan, expr, cparan
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        self.expr.generate( igen, *args, **kwargs )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'expr-paran: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ExprTernary( NonTerminal ):
    """class to handle `expr QMARK expr COLON expr` grammar."""

    def __init__( self, parser, pred, qmark, exprcolon ) :
        NonTerminal.__init__( self, parser, pred, qmark, exprcolon )
        self._terms = (self.QMARK,) = (qmark,)
        self._nonterms = self.predicate, self.exprcolon = pred, exprcolon
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self.predicate, self.QMARK, self.exprcolon

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'expr-ternary: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Term( NonTerminal ):
    """class to handle `term` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'term: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Number( TerminalS ): pass
class Dimension( TerminalS ): pass


# Gotcha : This node can make an indirect recursive call to expr, hence end up
# in deep recursion

class FuncCall( NonTerminal ):
    """class to handle `func_call` grammar."""

    def __init__( self, parser, fun, exprs, simpsel, cparan ) :
        NonTerminal.__init__( self, parser, fun, exprs, simpsel, cparan )
        self._terms = (self.FUNCTION,) = (fun,)
        self._nonterms = \
            self.exprs, self.simple_selector, self.closeparan = \
                exprs, simpsel, cparan
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = self.FUNCTION, self.exprs, self.simple_selector, self.closeparan
        return filter( None, x )

    def generate( self, igen, *args, **kwargs ):
        fnname = self.FUNCTION.dump(None)
        if (not self.simple_selector) and fnname.startswith('tss') :
            igen.evalfun( self.dump(None) )
        else :
            NonTerminal.generate( self, igen, *args, **kwargs )

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'func_call: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

class Ident( TerminalS ): pass
class String( TerminalS ): pass
class Uri( TerminalS ): pass
class UnicodeRange( TerminalS ): pass
class Hash( TerminalS ): pass


class WC( NonTerminal ):
    """class to handle `wc` grammar."""

    def __init__( self, parser, wc, s, comment ) :
        NonTerminal.__init__( self, parser, wc, s, comment )
        self._nonterms = (self.wc,) = (wc,)
        self._nonterms = filter( None, self._nonterms )
        self._terms = self.S, self.COMMENT = s, comment
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def dump( self, context ):
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'wc', ('S', 'COMMENT') )


class Any( NonTerminal ):
    """class to handle `any` grammar."""

    def __init__( self, parser, osqr, expr, csqr ) :
        NonTerminal.__init__( self, parser, osqr, expr, csqr )
        self._nonterms = self.opensqr, self.expr, self.closesqr = osqr,expr,csqr
        # Set parent attribute for children, should be last statement !! 
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.children() ]


#---- Extension language

class ExtnExpr( NonTerminal ):
    """class to handle `extn_expr` grammar."""

    def __init__( self, parser, extn_expr, ws ) :
        NonTerminal.__init__( self, parser, extn_expr, ws )
        self._terms = self.EXTN_EXPR, self.S = extn_expr, ws
        self._terms = filter( None, self._terms )

    def children( self ):
        return self._terms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'extn_expr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class FunctionDef( NonTerminal ):
    """class to handle `functiondef` grammar."""

    def __init__( self, parser, functionstart, functionbody ) :
        NonTerminal.__init__( self, parser, functionstart, functionbody )
        self._nonterms = self.functionstart, self.functionbody = \
                functionstart, functionbody

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'functiondef: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class IfelfiBlock( NonTerminal ):
    """class to handle `ifelfiblock` grammar."""

    def __init__( self, parser, ifblock, ifelfiblock, controlblock ) :
        NonTerminal.__init__( self, parser, ifblock, ifelfiblock, controlblock )
        self._nonterms = self.ifblock, self.ifelfiblock, self.controlblock = \
                ifblock, ifelfiblock, controlblock
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'ifelfiblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class IfBlock( NonTerminal ):
    """class to handle `ifblock` grammar."""

    def __init__( self, parser, ifcontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, ifcontrol, declarations, closebrace )
        self._nonterms = self.ifcontrol, self.declarations, self.closebrace = \
                ifcontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'ifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElifBlock( NonTerminal ):
    """class to handle `elifblock` grammar."""

    def __init__( self, parser, elifcontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, elifcontrol, declarations, closebrace )
        self._nonterms = self.elifcontrol, self.declarations, self.closebrace = \
                elifcontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'elifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElseBlock( NonTerminal ):
    """class to handle `elseblock` grammar."""

    def __init__( self, parser, elsecontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, elsecontrol, declarations, closebrace )
        self._nonterms = self.elsecontrol, self.declarations, self.closebrace = \
                elsecontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'elseblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ForBlock( NonTerminal ):
    """class to handle `forblock` grammar."""

    def __init__( self, parser, forcontrol, declaration, closebrace ) :
        NonTerminal.__init__( self, parser, forcontrol, declarations, closebrace )
        self._nonterms = self.forcontrol, self.declarations, self.closebrace = \
                forcontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'functiondef: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class WhileBlock( NonTerminal ):
    """class to handle `whileblock` grammar."""

    def __init__( self, parser, whilecontrol, declarations, closebrace ) :
        NonTerminal.__init__( self, parser, whilecontrol, declarations, closebrace )
        self._nonterms = \
            self.whilecontrol, self.declarations, self.closebrace = \
                whilecontrol, declarations, closebrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
        lead = ' ' * offset
        buf.write( lead + 'whileblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Openbrace( TerminalS ): pass
class Closebrace( TerminalS ): pass
class Opensqr( TerminalS ): pass
class Closesqr( TerminalS ): pass
class Openparan( TerminalS ): pass
class Closeparan( TerminalS ): pass
class Cdo( TerminalS ): pass
class Cdc( TerminalS ): pass

#-------------------------- AST Terminals -------------------------

class IMPORT_SYM( Terminal ) : pass
class PAGE_SYM( Terminal ) : pass
class MEDIA_SYM( Terminal ) : pass
class FONT_FACE_SYM( Terminal ) : pass
class CHARSET_SYM( Terminal ) : pass
class NAMESPACE_SYM( Terminal ) : pass
class IMPORTANT_SYM( Terminal ) : pass
class ATKEYWORD( Terminal ) : pass

class CDO( Terminal ) : pass
class CDATATEXT( Terminal ) : pass
class CDC( Terminal ) : pass
class S( Terminal ) : pass
class COMMENT( Terminal ) : pass

class IDENT( Terminal ) : pass
class URI( Terminal ) : pass
class FUNCTION( Terminal ) : pass
class FUNTEXT( Terminal ) : pass
class FUNCLOSE( Terminal ) : pass

class HASH( Terminal ) : pass
class INCLUDES( Terminal ) : pass
class DASHMATCH( Terminal ) : pass
class PREFIXMATCH( Terminal ) : pass
class SUFFIXMATCH( Terminal ) : pass
class SUBSTRINGMATCH( Terminal ) : pass

class PERCENTAGE( Terminal ) : pass

class UNICODERANGE( Terminal ) : pass
class DLIMIT( Terminal ) : pass

class PLUS( Terminal ) : pass
class MINUS( Terminal ) : pass
class GT( Terminal ) : pass
class LT( Terminal ) : pass
class TILDA( Terminal ) : pass
class COMMA( Terminal ) : pass
class COLON( Terminal ) : pass
class EQUAL( Terminal ) : pass
class DOT( Terminal ) : pass
class STAR( Terminal ) : pass
class PREFIXSTAR( Terminal ) : pass
class SEMICOLON( Terminal ) : pass
class FWDSLASH( Terminal ) : pass
class AND( Terminal ) : pass
class OR( Terminal ) : pass
class QMARK( Terminal ) : pass
class OPENBRACE( Terminal ) : pass
class CLOSEBRACE( Terminal ) : pass
class OPENSQR( Terminal ) : pass
class CLOSESQR( Terminal ) : pass
class OPENPARAN( Terminal ) : pass
class CLOSEPARAN( Terminal ) : pass

class EXTN_EXPR( Terminal ) : pass
class EXTN_STATEMENT( Terminal ) : pass
class PERCENT( Terminal ) : pass
class FUNCTIONSTART( Terminal ) : pass
class FUNCTIONBODY( Terminal ) : pass
class IFCONTROL( Terminal ) : pass
class ELIFCONTROL( Terminal ) : pass
class ELSECONTROL( Terminal ) : pass
class FORCONTROL( Terminal ) : pass
class WHILECONTROL( Terminal ) : pass

# TODO : Why are these terminal here ?
class HEXCOLOR( Terminal ) : pass
class NAME( Terminal ) : pass
class FUNCTIONEND( Terminal ) : pass

#---- Terminals abstracted as DIMENSION
class DIMENSION( Terminal ):
    def generate( self, igen, *args, **kwargs ):
        clsnm = self.__class__.__name__
        igen.pushobj( self.emit() )

    def emit( self ):
        return '%s_( %s )' % (self.__class__.__name__, self.terminal)

class DIMENSION_( object ):
    suffix = u''
    def __init__( self, value ):
        self.value = value

    def __str__( self ):
        return self.value

    def value( self ):
        t = self.value
        return float(t) if '.' in t else int(t)

    def __add__( self, y ):
        return self.__class__( str(self.value()+y.value()) + self.suffix )

    def __sub__( self, y ):
        return self.__class__( str(self.value()-y.value()) + self.suffix )

    def __mul__( self, y ):
        return self.__class__( str(self.value()*y.value()) + self.suffix )

    def __div__( self, y ):
        return self.__class__( str(self.value()/y.value()) + self.suffix )

class EMS( DIMENSION ): pass
class EMS_( DIMENSION_ ):
    suffix = 'em'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class EXS( DIMENSION ): pass
class EXS_( DIMENSION ):
    suffix = 'ex'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class LENGTHPX( DIMENSION ): pass
class LENGTHPX_( DIMENSION ):
    suffix = 'px'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class LENGTHCM( DIMENSION ): pass
class LENGTHCM_( DIMENSION ):
    suffix = 'cm'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class LENGTHMM( DIMENSION ): pass
class LENGTHMM_( DIMENSION ):
    suffix = 'mm'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class LENGTHIN( DIMENSION ): pass
class LENGTHIN_( DIMENSION ):
    suffix = 'in'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class LENGTHPT( DIMENSION ): pass
class LENGTHPT_( DIMENSION ):
    suffix = 'pt'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class LENGTHPC( DIMENSION ): pass
class LENGTHPC_( DIMENSION ):
    suffix = 'pc'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class ANGLEDEG( DIMENSION ): pass
class ANGLEDEG_( DIMENSION ):
    suffix = 'deg'
    def value( self ):
        t = self.value[:-3]
        return float(t) if '.' in t else int(t)

class ANGLERAD( DIMENSION ): pass
class ANGLERAD_( DIMENSION ):
    suffix = 'rad'
    def value( self ):
        t = self.value[:-3]
        return float(t) if '.' in t else int(t)

class ANGLEGRAD( DIMENSION ): pass
class ANGLEGRAD_( DIMENSION ):
    suffix = 'grad'
    def value( self ):
        t = self.value[:-4]
        return float(t) if '.' in t else int(t)

class TIMEMS( DIMENSION ): pass
class TIMEMS_( DIMENSION ):
    suffix = 'ms'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class TIMES( DIMENSION ): pass
class TIMES_( DIMENSION ):
    suffix = 's'
    def value( self ):
        t = self.value[:-1]
        return float(t) if '.' in t else int(t)

class FREQHZ( DIMENSION ): pass
class FREQHZ_( DIMENSION ):
    suffix = 'Hz'
    def value( self ):
        t = self.value[:-2]
        return float(t) if '.' in t else int(t)

class FREQKHZ( DIMENSION ): pass
class FREQKHZ_( DIMENSION ):
    suffix = 'kHz'
    def value( self ):
        t = self.value[:-3]
        return float(t) if '.' in t else int(t)

class PERCENTAGE( DIMENSION ): pass
class PERCENTAGE_( DIMENSION ):
    suffix = '%'
    def value( self ):
        t = self.value[:-1]
        return float(t) if '.' in t else int(t)


#---- Special Terminals

class NUMBER( Terminal ):
    def generate( self, igen, *args, **kwargs ):
        clsnm = self.__class__.__name__
        igen.pushobj( self.emit() )

    def emit( self ):
        return '%s_( None, %r )' % (self.__class__.__name__, self.terminal)

class NUMBER_( object ):
    def __init__( self, value ):
        self.value = value

    def __str__( self ):
        return str(self.value)

    def value( self ):
        t = self.value
        return float(t) if '.' in t else int(t)

    def __add__( self, y ):
        return self.__class__( str(self.value()+y.value()) + self.suffix )

    def __sub__( self, y ):
        return self.__class__( str(self.value()-y.value()) + self.suffix )

    def __mul__( self, y ):
        return self.__class__( str(self.value()*y.value()) + self.suffix )

    def __div__( self, y ):
        return self.__class__( str(self.value()/y.value()) + self.suffix )

class STRING( Terminal ):
    def generate( self, igen, *args, **kwargs ):
        clsnm = self.__class__.__name__
        igen.pushobj( self.emit() )

    def emit( self ):
        return '%s_( None, %s )' % (self.__class__.__name__, self.terminal)

class STRING_( object ):
    def __init__( self, value ):
        self.value = value

    def __str__( self ):
        return self.value

    def value( self ):
        t = self.value
        return float(t) if '.' in t else int(t)

    def __add__( self, y ):
        return self.__class__( str(self.value()+y.value()) + self.suffix )

    def __sub__( self, y ):
        return self.__class__( str(self.value()-y.value()) + self.suffix )

    def __mul__( self, y ):
        return self.__class__( str(self.value()*y.value()) + self.suffix )

    def __div__( self, y ):
        return self.__class__( str(self.value()/y.value()) + self.suffix )


class HASH( DIMENSION ):
    def dump( self, context ):
        funccall = getattr( context, 'funccall', False )
        return ('%r' % self.terminal) if funccall else self.terminal
